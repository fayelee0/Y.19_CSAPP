#+AUTHOR: Fei Li
#+EMAIL: wizard@pursuetao.com
* 程序的机器级表示

** 程序编码

*** 机器级代码

    计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。
    
    *最重要的两种抽象*
    1. 由指令集体系架构来定义机器级程序的格式和行为
       
       *ISA 定义了处理器状态、指令的格式，以及每条指令对状态的影响*
       
    2. 机器级程序使用的内存地址是虚拟地址
       
       *虚拟地址提供的内存模型看上去是一个非常大的字节数组*


    #+BEGIN_EXAMPLE
    gcc -Og -S mstore.c  // mstore.s
    gcc -Og -c mstore.c  // mstore.o

    objdump -d mstore.o
    gdb
    > file mstore.o
    > x/14xb multstore
    #+END_EXAMPLE


** 访问信息

*** 操作数指示符
    
    1. 立即数
    2. 寄存器
    3. 存储器


*** 数据传送指令

    这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指定的最后一个字符指定的大小匹配。

    #+CAPTION: MOV
    | Instruction  | Effect | Description             |
    |--------------+--------+-------------------------|
    | MOV     S, D | D <- S | Move                    |
    |--------------+--------+-------------------------|
    | movb         |        | Move byte               |
    | movw         |        | Move word               |
    | movl         |        | Move double word        |
    | movq         |        | Move quad word          |
    | movabsq I, R | R <- I | Move absolute quad word |


    #+CAPTION: MOVZ
    | Instruction  | Effect             | Description                            |
    |--------------+--------------------+----------------------------------------|
    | MOVZ    S, R | R <- ZeroExtend(S) | Move with zero extension               |
    |--------------+--------------------+----------------------------------------|
    | movzbw       |                    | Move zero-extended byte to word        |
    | movzbl       |                    | Move zero-extended byte to double word |
    | movzbq       |                    | Move zero-extended byte to quad word   |
    | movzwl       |                    | Move zero-extended word to doubld word |
    | movzwq       |                    | Move zero-extended word to quad word   |


    #+CAPTION: MOVS
    | Instruction  | Effect                   | Description                                 |
    |--------------+--------------------------+---------------------------------------------|
    | MOVS    S, R | R <- SignExtend(S)       | Move with sign extension                    |
    |--------------+--------------------------+---------------------------------------------|
    | movsbw       |                          | Move sign-extended byte to word             |
    | movsbl       |                          | Move sign-extended byte to double word      |
    | movsbq       |                          | Move sign-extended byte to quad word        |
    | movswl       |                          | Move sign-extended word to double word      |
    | movswq       |                          | Move sign-extended word to quad word        |
    | movslq       |                          | Move sign-extended double word to quad word |
    | cltq         | %rax <- SignExtend(%eax) | Sign-extend %eax to %rax                    |


    #+CAPTION: STACK
    | Instruction | Effect                    | Description    |
    |-------------+---------------------------+----------------|
    | pushq   S   | R[%rsp]    <- R[%rsp] - 8 | Push quad word |
    |             | M[R[%rsp]] <- S           |                |
    | popq    D   | D          <- M[R[%rsp]]  | Pop quad word  |
    |             | R[%rsp]    <- R[%rsp] + 8 |                |

    
    #+BEGIN_SRC asm
    movabsq $0x0011223344556677, %rax # %rax = 0011223344556677
    movb    $0xAA, %dl                # %dl  = AA
    movb    %dl, %al                  # %rax = 00112233445566AA
    movsbq  %dl, %rax                 # %rax = FFFFFFFFFFFFFFAA
    movzbq  %dl, %rax                 # %rax = 00000000000000AA
    #+END_SRC


    #+BEGIN_SRC asm c
    long exchange(long* xp, long y)
    { 
        long x = *xp;
        *xp = y;
        return x;
    }

    # long exchange(long* xp, long y)
    # xp in %rdi, y in %rsi
    exchange:
      movq    (%rdi), %rax
      movq    %rsi, (%rdi)
      ret
    #+END_SRC

    *C 语言所谓的「指针」其实就是地址*
    间接引用指针就是将该指针放到一个寄存器中，然后在内存引用中使用这个寄存器。
    局部变量通常是保存在寄存器中，而不是内存中。


** 算术和逻辑操作
    
   | Instruction | Effect         | Description              |
   |-------------+----------------+--------------------------|
   | leaq   S, D | D <- &S        | Load effective address   |
   |-------------+----------------+--------------------------|
   | INC    D    | D <- D + 1     | Increment                |
   | DEC    D    | D <- D - 1     | Decrement                |
   | NEG    D    | D <- -D        | Negate                   |
   | NOT    D    | D <- ~D        | Complement               |
   |-------------+----------------+--------------------------|
   | ADD    S, D | D <- D + S     | Add                      |
   | SUB    S, D | D <- D - S     | Substract                |
   | IMUL   S, D | D <- D * S     | Multiply                 |
   | XOR    S, D | D <- D ^ S     | Exclusive-or             |
   | OR     S, D | D <- D \vert S | Or                       |
   | AND    S, D | D <- D & S     | And                      |
   |-------------+----------------+--------------------------|
   | SAL    k, D | D <- D << k    | Left shift               |
   | SHL    k, D | D <- D << k    | Left shift (same as SAL) |
   | SAR    k, D | D <- D >>(A) k | Arithmetic right shift   |
   | SHR    k, D | D <- D >>(L) k | Logical right shift      |


   | Instruction | Effect                                  | Description            |
   |-------------+-----------------------------------------+------------------------|
   | imulq   S   | R[%rdx]: R[%rax] <- S * R[%rax]         | Signed full multiply   |
   | mulq    S   | R[%rdx]: R[%rax] <- S * R[%rax]         | Unsigned full multiply |
   |-------------+-----------------------------------------+------------------------|
   | clto    S   | R[%rdx]: R[%rax] <- SignExtend(R[%rax]) | Convert to oct word    |
   |-------------+-----------------------------------------+------------------------|
   | idivq   S   | R[%rdx] <- R[%rdx]: R[%rax] mod S       | Signed divide          |
   | divq    S   | R[%rdx] <- R[%rdx]: R[%rax] / S         | Unsigned divide        |


** 控制

   机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

*** 条件码

    *最常用的条件码*
    *CF* 进位标志 /最近的操作使最高位产生了进位，可用来检查无符号操作的溢出/
    *ZF*   零标志 /最近的操作得到的结果为 0/
    *SF* 符号标志 /最近的操作得到的结果为负数/
    *OF* 溢出标志 /最近的操作导致一个补码溢出——正溢出或负溢出/

    #+BEGIN_EXAMPLE
    int a = random();
    int b = random();
    int t = random();
    t = a + b;

    CF    (unsigned) t < (unsigned) a              # unsigned overflow
    ZF    (t == 0)                                 # zero
    SF    (t < 0)                                  # negate
    OF    (a < 0 == b < 0) && (t < 0 != a < 0)     # signed overflow
    #+END_EXAMPLE

    #+CAPTION: CMP
    | Instruction   | Effect  | Description         |
    |---------------+---------+---------------------|
    | CMP    S1, S2 | S2 - S1 | Compare             |
    |---------------+---------+---------------------|
    | cpmb          |         | Compare byte        |
    | cpmw          |         | Compare word        |
    | cpml          |         | Compare double word |
    | cpmq          |         | Compare quad word   |

    
    #+CAPTION: TEST
    | Instruction    | Effect  | Description      |
    |----------------+---------+------------------|
    | TEST    S1, S2 | S1 & S2 | Test             |
    |----------------+---------+------------------|
    | testb          |         | Test byte        |
    | testw          |         | Test word        |
    | testl          |         | Test double word |
    | testq          |         | Test quad word   |


    *访问条件码*
    1. 可以根据条件码的某种组合，将一个字设置为 0 或 1
    2. 可以条件跳转到程序的某个其他的部分
    3. 可以有条件地传送数据


    #+CAPTION: SET
    | Instruction | Synonym | Effect                  | Description                    |
    |-------------+---------+-------------------------+--------------------------------|
    | sete    D   | setz    | D <- ZF                 | Equal / zero                   |
    | setne   D   | setnz   | D <- ~ZF                | Not equal / not zero           |
    | sets    D   |         | D <- SF                 | Negative                       |
    | setns   D   |         | D <- ~SF                | Nonnegative                    |
    | setg    D   | setnle  | D <- ~(SF ^ OF) & ~ZF   | Greater          (signed   > ) |
    | setge   D   | setnl   | D <- ~(SF ^ OF)         | Greater or equal (signed   >=) |
    | setl    D   | setnge  | D <- SF ^ OF            | Less             (signed   < ) |
    | setle   D   | setng   | D <- (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
    | seta    D   | setnbe  | D <- ~CF & ~ZF          | Above            (unsigned > ) |
    | setae   D   | setnb   | D <- ~CF                | Above or equal   (unsigned >=) |
    | setb    D   | setnae  | D <- CF                 | Below            (unsigned < ) |
    | setbe   D   | setna   | D <- CF \vert ZF        | Below or equal   (unsigned <=) |


    #+CAPTION: JUMP
    | Instruction     | Synonym | Effect             | Description                    |
    |-----------------+---------+--------------------+--------------------------------|
    | jmp    Label    |         | 1                  | Direct jump                    |
    | jmp    *Operand |         | 1                  | Indirect jump                  |
    | je     Label    | jz      | ZF                 | Equal / zero                   |
    | jne    Label    | jnz     | ~ZF                | Not equal / not zero           |
    | js     Label    |         | SF                 | Negative                       |
    | jns    Label    |         | ~SF                | Nonnegative                    |
    | jg     Label    | jnle    | ~(SF ^ OF) & ~ZF   | Greater          (sgined   > ) |
    | jge    Label    | jnl     | ~(SF ^ OF)         | Greater or equal (signed   >=) |
    | jl     Label    | jnge    | SF ^ OF            | Less             (signed   < ) |
    | jle    Label    | jng     | (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
    | ja     Label    | jnbe    | ~CF & ~ZF          | Above            (unsigned > ) |
    | jae    Label    | jnb     | ~CF                | Above or equal   (unsigned >=) |
    | jb     Label    | jnae    | CF                 | Below            (unsigned < ) |
    | jbe    Label    | jna     | CF \vert ZF        | Below or equal   (unsigned <=) |


*** 条件分支的实现

**** 条件控制

     *将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转*

     #+BEGIN_SRC c
     if (test-expr) {
         then-statement;
     } else {
         else-statement;
     }

     t = test-expr;
     if (!t) {
         goto false;
     }
     then-statement;
     goto done;

     false:
         else-statement;
     done:
     #+END_SRC


**** 条件转移

     +传统的方式效率底下+
     +实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径+
     
     *替代的策略*
     *使用数据的条件转移，计算一个条件操作的两个结果，然后根据条件是否满足从中选取一个*
     /只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，其更符合现代处理器的性能特性/


     *处理器通过使用流水线来获得高性能*
     在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存读取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）
     这种方法通过重叠连续指令的步骤获得高性能。

     | Instruction   | Synonym | Effect             | Description                    |
     |---------------+---------+--------------------+--------------------------------|
     | cmove    S, R | cmovz   | ZF                 | Equal / zero                   |
     | cmovne   S, R | cmovnz  | ~ZF                | Not equal / not zero           |
     | cmovs    S, R |         | SF                 | Negative                       |
     | cmovns   S, R |         | ~SF                | Nonnegative                    |
     | cmovg    S, R | cmovnle | ~(SF ^ OF) & ~ZF   | Greater          (signed   > ) |
     | cmovge   S, R | cmovnl  | ~(SF ^ OF)         | Greater or equal (signed   >=) |
     | cmovl    S, R | cmovnge | SF ^ OF            | Less             (signed   < ) |
     | cmovle   S, R | cmovng  | (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
     | cmova    S, R | cmovnbe | ~CF & ~ZF          | Above            (unsigned > ) |
     | cmovae   S, R | cmovnb  | ~CF                | Above or equal   (unsigned >=) |
     | cmovb    S, R | cmovnae | CF                 | Below            (unsigned < ) |
     | cmovbe   S, R | cmovna  | CF \vert ZF        | Below or equal   (unsigned <=) |


     #+BEGIN_SRC c
     /* C */
     v = test-expr ? then-expr : else-expr;

     /* tradition jump */
     if (!test-expr) {
         goto false;
     }

     v = then-expr;
     goto done;

     false:
         v = else-expr;

     done:

     /* condition move */
     v  = then-expr;
     ve = else-expr;
     t  = test-expr;
     if (!t) {
         v = ve;
     }
     #+END_SRC
     

*** 循环

**** do-while

     #+BEGIN_SRC c
     do {
         body-statement
     } while (test-expr);


     loop:
       body-statement
       t = test-expr
       if (t) {
           goto loop;
       }
     #+END_SRC

**** while

     #+BEGIN_SRC c
     /* C */
     while (test-expr) {
         body-statement
     }
     

     /* while */
         goto test;
     loop:
         body-statement;

     test:
         t = test-expr;
         if (t) {
             goto loop;
         }


     /* do-while */
     t = test-expr;
     if (!t) {
         goto done;
     }

     do {
         body-statement;
     } while (test-expr);

     done:


     /* do-while goto */
     t = test-expr;
     if (!t) {
         goto done;
     }
     
     loop:
         body-statement;
         t = test-expr;
         if (t) {
             goto loop;
         }

     done:
         
     #+END_SRC
     

**** for

     #+BEGIN_SRC c
     /* C for */
     for (init-expr; test-expr; update-expor) {
         body-statement;
     }
     
     /* C while */
     init-expr;
     while (test-expr) {
         body-statement;
         update-expr;
     }

     /* while */
     init-expr;
     goto test;

     loop:
         body-statement;
         update-expr;

     test:
         t = test-expr;
         if (t) {
             goto loop;
         }


     /* guarded-do */
     init-expr;
     t = test-expr;
     if (!t) {
         goto done;
     }

     loop:
         body-statement;
         update-expr;
         t = test-expr;
         if (t) {
             goto loop;
         }
     
     done:
     #+END_SRC


** 过程

   *过程调用机制 P->Q->P*
   1. 传递控制

      在进入过程 Q 的时候，PC 必须被设置为 Q 的代码的起始地址，然后在返回的时候，要把 PC 设置为 P 中调用 Q 的后面的那条指令的地址

   2. 传递数据

      P 必须能向 Q 提供一个或多个参数， Q 必须能够向 P 返回一个值

   3. 分配和释放内存

      在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间


*** 转移控制

    | Instruction   | Description      |
    |---------------+------------------|
    | call Label    | Procedure call   |
    | call *Operand | Procedure call   |
    | ret           | Return from call |


*** 数据传送

    通过寄存器最多传递 6 个整型参数（%rdi, %rsi, %rdx, %rcx, %r8, %r9)
    如果一个参数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递（把参数 7~n 放到栈上，参数 7 位于栈顶）

    
*** 栈上的局部变量

    *常见的局部变量必须存放在内存中的情况*
    1. 寄存器不足够存放所有的本地数据
    2. 对一个局部变量使用地址运算符 *&* ，因此必须能够为它产生一个地址
    3. 某些局部变量是数据和结构，因此必须能够通过数组和结构引用被访问到
