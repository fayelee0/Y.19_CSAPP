#+AUTHOR: Fei Li
#+EMAIL: wizard@pursuetao.com
* 程序的机器级表示

** 程序编码

*** 机器级代码

    计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。
    
    *最重要的两种抽象*
    1. 由指令集体系架构来定义机器级程序的格式和行为
       
       *ISA 定义了处理器状态、指令的格式，以及每条指令对状态的影响*
       
    2. 机器级程序使用的内存地址是虚拟地址
       
       *虚拟地址提供的内存模型看上去是一个非常大的字节数组*


    #+BEGIN_EXAMPLE
    gcc -Og -S mstore.c  // mstore.s
    gcc -Og -c mstore.c  // mstore.o

    objdump -d mstore.o
    gdb
    > file mstore.o
    > x/14xb multstore
    #+END_EXAMPLE


** 访问信息

*** 操作数指示符
    
    1. 立即数
    2. 寄存器
    3. 存储器


*** 数据传送指令

    这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指定的最后一个字符指定的大小匹配。

    #+CAPTION: MOV
    | Instruction  | Effect | Description             |
    |--------------+--------+-------------------------|
    | MOV     S, D | D <- S | Move                    |
    |--------------+--------+-------------------------|
    | movb         |        | Move byte               |
    | movw         |        | Move word               |
    | movl         |        | Move double word        |
    | movq         |        | Move quad word          |
    | movabsq I, R | R <- I | Move absolute quad word |


    #+CAPTION: MOVZ
    | Instruction  | Effect             | Description                            |
    |--------------+--------------------+----------------------------------------|
    | MOVZ    S, R | R <- ZeroExtend(S) | Move with zero extension               |
    |--------------+--------------------+----------------------------------------|
    | movzbw       |                    | Move zero-extended byte to word        |
    | movzbl       |                    | Move zero-extended byte to double word |
    | movzbq       |                    | Move zero-extended byte to quad word   |
    | movzwl       |                    | Move zero-extended word to doubld word |
    | movzwq       |                    | Move zero-extended word to quad word   |


    #+CAPTION: MOVS
    | Instruction  | Effect                   | Description                                 |
    |--------------+--------------------------+---------------------------------------------|
    | MOVS    S, R | R <- SignExtend(S)       | Move with sign extension                    |
    |--------------+--------------------------+---------------------------------------------|
    | movsbw       |                          | Move sign-extended byte to word             |
    | movsbl       |                          | Move sign-extended byte to double word      |
    | movsbq       |                          | Move sign-extended byte to quad word        |
    | movswl       |                          | Move sign-extended word to double word      |
    | movswq       |                          | Move sign-extended word to quad word        |
    | movslq       |                          | Move sign-extended double word to quad word |
    | cltq         | %rax <- SignExtend(%eax) | Sign-extend %eax to %rax                    |


    #+CAPTION: STACK
    | Instruction | Effect                    | Description    |
    |-------------+---------------------------+----------------|
    | pushq   S   | R[%rsp]    <- R[%rsp] - 8 | Push quad word |
    |             | M[R[%rsp]] <- S           |                |
    | popq    D   | D          <- M[R[%rsp]]  | Pop quad word  |
    |             | R[%rsp]    <- R[%rsp] + 8 |                |

    
    #+BEGIN_SRC asm
    movabsq $0x0011223344556677, %rax # %rax = 0011223344556677
    movb    $0xAA, %dl                # %dl  = AA
    movb    %dl, %al                  # %rax = 00112233445566AA
    movsbq  %dl, %rax                 # %rax = FFFFFFFFFFFFFFAA
    movzbq  %dl, %rax                 # %rax = 00000000000000AA
    #+END_SRC


    #+BEGIN_SRC asm c
    long exchange(long* xp, long y)
    { 
        long x = *xp;
        *xp = y;
        return x;
    }

    # long exchange(long* xp, long y)
    # xp in %rdi, y in %rsi
    exchange:
      movq    (%rdi), %rax
      movq    %rsi, (%rdi)
      ret
    #+END_SRC

    *C 语言所谓的「指针」其实就是地址*
    间接引用指针就是将该指针放到一个寄存器中，然后在内存引用中使用这个寄存器。
    局部变量通常是保存在寄存器中，而不是内存中。


** 算术和逻辑操作
    
   | Instruction | Effect         | Description              |
   |-------------+----------------+--------------------------|
   | leaq   S, D | D <- &S        | Load effective address   |
   |-------------+----------------+--------------------------|
   | INC    D    | D <- D + 1     | Increment                |
   | DEC    D    | D <- D - 1     | Decrement                |
   | NEG    D    | D <- -D        | Negate                   |
   | NOT    D    | D <- ~D        | Complement               |
   |-------------+----------------+--------------------------|
   | ADD    S, D | D <- D + S     | Add                      |
   | SUB    S, D | D <- D - S     | Substract                |
   | IMUL   S, D | D <- D * S     | Multiply                 |
   | XOR    S, D | D <- D ^ S     | Exclusive-or             |
   | OR     S, D | D <- D \vert S | Or                       |
   | AND    S, D | D <- D & S     | And                      |
   |-------------+----------------+--------------------------|
   | SAL    k, D | D <- D << k    | Left shift               |
   | SHL    k, D | D <- D << k    | Left shift (same as SAL) |
   | SAR    k, D | D <- D >>(A) k | Arithmetic right shift   |
   | SHR    k, D | D <- D >>(L) k | Logical right shift      |


   | Instruction | Effect                                  | Description            |
   |-------------+-----------------------------------------+------------------------|
   | imulq   S   | R[%rdx]: R[%rax] <- S * R[%rax]         | Signed full multiply   |
   | mulq    S   | R[%rdx]: R[%rax] <- S * R[%rax]         | Unsigned full multiply |
   |-------------+-----------------------------------------+------------------------|
   | clto    S   | R[%rdx]: R[%rax] <- SignExtend(R[%rax]) | Convert to oct word    |
   |-------------+-----------------------------------------+------------------------|
   | idivq   S   | R[%rdx] <- R[%rdx]: R[%rax] mod S       | Signed divide          |
   | divq    S   | R[%rdx] <- R[%rdx]: R[%rax] / S         | Unsigned divide        |


** 控制

   机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

*** 条件码

    *最常用的条件码*
    *CF* 进位标志 /最近的操作使最高位产生了进位，可用来检查无符号操作的溢出/
    *ZF*   零标志 /最近的操作得到的结果为 0/
    *SF* 符号标志 /最近的操作得到的结果为负数/
    *OF* 溢出标志 /最近的操作导致一个补码溢出——正溢出或负溢出/

    #+BEGIN_EXAMPLE
    int a = random();
    int b = random();
    int t = random();
    t = a + b;

    CF    (unsigned) t < (unsigned) a              # unsigned overflow
    ZF    (t == 0)                                 # zero
    SF    (t < 0)                                  # negate
    OF    (a < 0 == b < 0) && (t < 0 != a < 0)     # signed overflow
    #+END_EXAMPLE

    #+CAPTION: CMP
    | Instruction   | Effect  | Description         |
    |---------------+---------+---------------------|
    | CMP    S1, S2 | S2 - S1 | Compare             |
    |---------------+---------+---------------------|
    | cpmb          |         | Compare byte        |
    | cpmw          |         | Compare word        |
    | cpml          |         | Compare double word |
    | cpmq          |         | Compare quad word   |

    
    #+CAPTION: TEST
    | Instruction    | Effect  | Description      |
    |----------------+---------+------------------|
    | TEST    S1, S2 | S1 & S2 | Test             |
    |----------------+---------+------------------|
    | testb          |         | Test byte        |
    | testw          |         | Test word        |
    | testl          |         | Test double word |
    | testq          |         | Test quad word   |


    *访问条件码*
    1. 可以根据条件码的某种组合，将一个字设置为 0 或 1
    2. 可以条件跳转到程序的某个其他的部分
    3. 可以有条件地传送数据


    #+CAPTION: SET
    | Instruction | Synonym | Effect                  | Description                    |
    |-------------+---------+-------------------------+--------------------------------|
    | sete    D   | setz    | D <- ZF                 | Equal / zero                   |
    | setne   D   | setnz   | D <- ~ZF                | Not equal / not zero           |
    | sets    D   |         | D <- SF                 | Negative                       |
    | setns   D   |         | D <- ~SF                | Nonnegative                    |
    | setg    D   | setnle  | D <- ~(SF ^ OF) & ~ZF   | Greater          (signed   > ) |
    | setge   D   | setnl   | D <- ~(SF ^ OF)         | Greater or equal (signed   >=) |
    | setl    D   | setnge  | D <- SF ^ OF            | Less             (signed   < ) |
    | setle   D   | setng   | D <- (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
    | seta    D   | setnbe  | D <- ~CF & ~ZF          | Above            (unsigned > ) |
    | setae   D   | setnb   | D <- ~CF                | Above or equal   (unsigned >=) |
    | setb    D   | setnae  | D <- CF                 | Below            (unsigned < ) |
    | setbe   D   | setna   | D <- CF \vert ZF        | Below or equal   (unsigned <=) |


    #+CAPTION: JUMP
    | Instruction     | Synonym | Effect             | Description                    |
    |-----------------+---------+--------------------+--------------------------------|
    | jmp    Label    |         | 1                  | Direct jump                    |
    | jmp    *Operand |         | 1                  | Indirect jump                  |
    | je     Label    | jz      | ZF                 | Equal / zero                   |
    | jne    Label    | jnz     | ~ZF                | Not equal / not zero           |
    | js     Label    |         | SF                 | Negative                       |
    | jns    Label    |         | ~SF                | Nonnegative                    |
    | jg     Label    | jnle    | ~(SF ^ OF) & ~ZF   | Greater          (sgined   > ) |
    | jge    Label    | jnl     | ~(SF ^ OF)         | Greater or equal (signed   >=) |
    | jl     Label    | jnge    | SF ^ OF            | Less             (signed   < ) |
    | jle    Label    | jng     | (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
    | ja     Label    | jnbe    | ~CF & ~ZF          | Above            (unsigned > ) |
    | jae    Label    | jnb     | ~CF                | Above or equal   (unsigned >=) |
    | jb     Label    | jnae    | CF                 | Below            (unsigned < ) |
    | jbe    Label    | jna     | CF \vert ZF        | Below or equal   (unsigned <=) |


*** 条件分支的实现

**** 条件控制

     *将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转*

     #+BEGIN_SRC c
     if (test-expr) {
         then-statement;
     } else {
         else-statement;
     }

     t = test-expr;
     if (!t) {
         goto false;
     }
     then-statement;
     goto done;

     false:
         else-statement;
     done:
     #+END_SRC


**** 条件转移

     +传统的方式效率底下+
     +实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径+
     
     *替代的策略*
     *使用数据的条件转移，计算一个条件操作的两个结果，然后根据条件是否满足从中选取一个*
     /只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，其更符合现代处理器的性能特性/


     *处理器通过使用流水线来获得高性能*
     在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存读取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）
     这种方法通过重叠连续指令的步骤获得高性能。

     | Instruction   | Synonym | Effect             | Description                    |
     |---------------+---------+--------------------+--------------------------------|
     | cmove    S, R | cmovz   | ZF                 | Equal / zero                   |
     | cmovne   S, R | cmovnz  | ~ZF                | Not equal / not zero           |
     | cmovs    S, R |         | SF                 | Negative                       |
     | cmovns   S, R |         | ~SF                | Nonnegative                    |
     | cmovg    S, R | cmovnle | ~(SF ^ OF) & ~ZF   | Greater          (signed   > ) |
     | cmovge   S, R | cmovnl  | ~(SF ^ OF)         | Greater or equal (signed   >=) |
     | cmovl    S, R | cmovnge | SF ^ OF            | Less             (signed   < ) |
     | cmovle   S, R | cmovng  | (SF ^ OF) \vert ZF | Less or equal    (signed   <=) |
     | cmova    S, R | cmovnbe | ~CF & ~ZF          | Above            (unsigned > ) |
     | cmovae   S, R | cmovnb  | ~CF                | Above or equal   (unsigned >=) |
     | cmovb    S, R | cmovnae | CF                 | Below            (unsigned < ) |
     | cmovbe   S, R | cmovna  | CF \vert ZF        | Below or equal   (unsigned <=) |


     #+BEGIN_SRC c
     /* C */
     v = test-expr ? then-expr : else-expr;

     /* tradition jump */
     if (!test-expr) {
         goto false;
     }

     v = then-expr;
     goto done;

     false:
         v = else-expr;

     done:

     /* condition move */
     v  = then-expr;
     ve = else-expr;
     t  = test-expr;
     if (!t) {
         v = ve;
     }
     #+END_SRC
     

*** 循环

**** do-while

     #+BEGIN_SRC c
     do {
         body-statement
     } while (test-expr);


     loop:
       body-statement
       t = test-expr
       if (t) {
           goto loop;
       }
     #+END_SRC

**** while

     #+BEGIN_SRC c
     /* C */
     while (test-expr) {
         body-statement
     }
     

     /* while */
         goto test;
     loop:
         body-statement;

     test:
         t = test-expr;
         if (t) {
             goto loop;
         }


     /* do-while */
     t = test-expr;
     if (!t) {
         goto done;
     }

     do {
         body-statement;
     } while (test-expr);

     done:


     /* do-while goto */
     t = test-expr;
     if (!t) {
         goto done;
     }
     
     loop:
         body-statement;
         t = test-expr;
         if (t) {
             goto loop;
         }

     done:
         
     #+END_SRC
     

**** for

     #+BEGIN_SRC c
     /* C for */
     for (init-expr; test-expr; update-expor) {
         body-statement;
     }
     
     /* C while */
     init-expr;
     while (test-expr) {
         body-statement;
         update-expr;
     }

     /* while */
     init-expr;
     goto test;

     loop:
         body-statement;
         update-expr;

     test:
         t = test-expr;
         if (t) {
             goto loop;
         }


     /* guarded-do */
     init-expr;
     t = test-expr;
     if (!t) {
         goto done;
     }

     loop:
         body-statement;
         update-expr;
         t = test-expr;
         if (t) {
             goto loop;
         }
     
     done:
     #+END_SRC


** 过程

   *过程调用机制 P->Q->P*
   1. 传递控制

      在进入过程 Q 的时候，PC 必须被设置为 Q 的代码的起始地址，然后在返回的时候，要把 PC 设置为 P 中调用 Q 的后面的那条指令的地址

   2. 传递数据

      P 必须能向 Q 提供一个或多个参数， Q 必须能够向 P 返回一个值

   3. 分配和释放内存

      在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间


*** 转移控制

    | Instruction   | Description      |
    |---------------+------------------|
    | call Label    | Procedure call   |
    | call *Operand | Procedure call   |
    | ret           | Return from call |


*** 数据传送

    通过寄存器最多传递 6 个整型参数（%rdi, %rsi, %rdx, %rcx, %r8, %r9)
    如果一个参数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递（把参数 7~n 放到栈上，参数 7 位于栈顶）

    
*** 栈上的局部变量

    *常见的局部变量必须存放在内存中的情况*
    1. 寄存器不足够存放所有的本地数据
    2. 对一个局部变量使用地址运算符 *&* ，因此必须能够为它产生一个地址
    3. 某些局部变量是数据和结构，因此必须能够通过数组和结构引用被访问到


** 数组分配和访问

   #+BEGIN_EXAMPLE
   int E[N]

   E[i] ==> movl (%rdx,%rcx,4), %eax
   #+END_EXAMPLE

   
   #+CAPTION: E in %rdx, i in %rcx, store in %rax
   | Expression | Type | Value           | Assembly code               |
   |------------+------+-----------------+-----------------------------|
   | E          | int* | Xe              | movq %rdx, %rax             |
   | E[0]       | int  | M[Xe]           | movl (%rdx), %eax           |
   | E[i]       | int  | M[Xe + 4i]      | movl (%rdx,%rcx,4), %eax    |
   | &E[2]      | int* | Xe + 8          | leaq 8(%rdx), %rax          |
   | E+i-1      | int* | Xe + 4i - 4     | leaq -4(%rdx,%rcx,4), %rax  |
   | *(E+i-3)   | int  | M[Xe + 4i - 12] | movl -12(%rdx,%rcx,4), %eax |
   | &E[i]-E    | long | i               | movq %rcx, %rax             |


   #+CAPTION: nested arrays
   #+BEGIN_EXAMPLE
   int A[5][3];

   typedef int row3_t[3];
   row3_t A[5];
   #+END_EXAMPLE


** 异质的数据结构

*** 对齐
    
    | K | Type                |
    |---+---------------------|
    | 1 | char                |
    | 2 | short               |
    | 4 | int, float          |
    | 8 | long, double, void* |

    
    *对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数*
    *确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐*


** 在机器级程序中将控制与数据结合起来

*** 理解指针

**** 每个指针都对应一个类型
    
     *这个类型表明该指针指向的是哪一类对象*
     
     指针类型不是机器代码中的一部分，它们是 C 语言提供的一种抽象，帮助程序员避免寻址错误。
     
  
**** 每个指针都有一个值

     *这个值是某个指定类型的对象的地址*
     
     特殊的 NULL(0) 值表示该指针没有指向任何地方。


**** 指针用「&」运算符创建

     因为 *leaq* 指令是设计用来计算内存引用地址的，「&」运算符的机器代码实现常常用这条指令来计算表达式的值


**** 「*」操作符用于间接引用指针

     其结果是一个值，它的类型与该指针的类型一致。

     *间接引用是内存引用实现的，要么是存储到一个指定的地址，要么是从指定的地址读取*


**** 数组与指针紧密联系


**** 将指针从一种类型转换成另一种类型，只改变它的类型，而不改变它的值

     *强制类型转换的一个效果是改变指针运算的伸缩*


**** 指针也可以指向函数

     *函数指针的值是该函数机器代码表示中第一条指令的地址*


*** 内存越界引用和缓冲区溢出

    *缓冲区溢出* 在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间
    /可以让程序执行它本来不愿意执行的函数/
    
    


*** 对抗缓冲区溢出

**** 栈随机化

     *安全单一化* 对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的

     *栈随机化的思想使得栈的位置在程序每次运行时都有变化*

     Linux *ASLR* Address-Space Layout Randomization
     /从用 ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域/

     
**** 栈破坏检测

     *stack protector* 在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的 *canary* 值，也称为 *guard value*，是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。
     /在恢复寄存器状态和从函数返回之前，程序检查这个 canary 值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是，则程序异常终止。

     
**** 限制可执行代码区域     


** 浮点数代码

   #+CAPTION: VMOV
   | Instruction | Source | Destination | Description                           |
   |-------------+--------+-------------+---------------------------------------|
   | vmovss      | M32    | X           | Move single precision                 |
   | vmovss      | X      | M32         | Move single precision                 |
   | vmovsd      | M64    | X           | Move double precision                 |
   | vmovsd      | X      | M64         | Move double precision                 |
   | vmovaps     | X      | X           | Move aligned, packed signle precision |
   | vmovapd     | X      | X           | Move aligned, packed double precision |


   #+CAPTION: VCVTTS
   | Instruction | Source | Destination | Description                                                   |
   |-------------+--------+-------------+---------------------------------------------------------------|
   | vcvttss2si  | X/M32  | R32         | Convert with truncation single precision to integer           |
   | vcvttsd2si  | X/M64  | R32         | Convert with truncation double precision to integer           |
   | vcvttss2siq | X/M32  | R64         | Convert with truncation single precision to quad word integer |
   | vcvttsd2siq | X/M64  | R64         | Convert with truncation double precision to quad word integer |


   #+CAPTION: VCVTSI
   | Instruction | Source 1 | Source 2 | Destination | Description                                   |
   |-------------+----------+----------+-------------+-----------------------------------------------|
   | vcvtsi2ss   | M32/R32  | X        | X           | Convert integer to single precision           |
   | vcvtsi2sd   | M32/R32  | X        | X           | Convert integer to double precision           |
   | vcvtsi2ssq  | M64/R64  | X        | X           | Convert quad word integer to single precision |
   | vcvtsi2sdq  | M64/R64  | X        | X           | Convert quad word integer to double precision |


   #+CAPTION: operator
   | Single precision | Double precision | Effect           | Description                           |
   |------------------+------------------+------------------+---------------------------------------|
   | vaddss           | vaddsd           | D <- S2 + S1     | Floating-point add                    |
   | vsubss           | vsubsd           | D <- S2 - S1     | Floating-point subtract               |
   | vmulss           | vmulsd           | D <- S2 * S1     | Floating-point multiply               |
   | vdivss           | vdivsd           | D <- S2 / S1     | Floating-point divide                 |
   | vmaxss           | vmaxsd           | D <- max(S2, S1) | Floating-point maximum                |
   | vminss           | vminsd           | D <- min(S2, S1) | Floating-point minimum                |
   | sqrtss           | sqrtsd           | D <- sqrt(S1)    | Floating-point square root            |
   | vxorps           | vxorpd           | D <- S2 ^ S1     | Floating-point bit level exclusive-or |
   | vandps           | vandpd           | D <- S2 & S1     | Floating-point bit level and          |


   #+CAPTION: vucomi
   | Instruction     | Effect  | Description              |
   |-----------------+---------+--------------------------|
   | vucomiss S1, S2 | S2 - S1 | Compare single precision |
   | vucomisd S1, S2 | S2 - S1 | Compare double precision |


   | S2:S1       | CF | ZF | PF |
   |-------------+----+----+----|
   | non-ordered |  1 |  1 |  1 |
   | S2 < S1     |  1 |  0 |  0 |
   | S2 = S1     |  0 |  1 |  0 |
   | S2 > S1     |  0 |  0 |  1 |
