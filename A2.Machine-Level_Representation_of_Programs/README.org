* Machine-Level Representation of Programs

** Compiler

   #+BEGIN_SRC shell
   
   gcc -Og -o p p1.c p2.c

   gcc -Og -S mstore.s

   objdump -d mstore.o

   #+END_SRC


   #+CAPTION: Sizes of C data types in x86-64
   | C declaration | Intel data type         | Assembly-code suffix | Size (bytes) |
   |---------------+-------------------------+----------------------+--------------|
   | char          | byte                    | b                    |            1 |
   | short         | word                    | w                    |            2 |
   | int           | double word / long word | l                    |            4 |
   | long          | quad word               | q                    |            8 |
   | char*         | quad word               | q                    |            8 |
   | float         | single precision        | s                    |            4 |
   | double        | double precision        | l                    |            8 |

   
   #+CAPTION: Integer registers
   | 63b  | 31b   | 15b   | 7b    | 0b            |
   |------+-------+-------+-------+---------------|
   | %rax | %eax  | %ax   | %al   | return value  |
   | %rbx | %ebx  | %bx   | %bl   | callee saved  |
   | %rcx | %ecx  | %cx   | %cl   | 4th argument  |
   | %rdx | %edx  | %dx   | %dl   | 3rd argument  |
   | %rsi | %esi  | %si   | %sil  | 2nd argument  |
   | %rdi | %edi  | %di   | %dil  | 1st argument  |
   | %rbp | %ebp  | %bp   | %bpl  | callee saved  |
   | %rsp | %esp  | %sp   | %spl  | stack pointer |
   |------+-------+-------+-------+---------------|
   | %r8  | %r8d  | %r8w  | %r8b  | 5th argument  |
   | %r9  | %r9d  | %r9w  | %r9b  | 6th argument  |
   | %r10 | %r10d | %r10w | %r10b | caller saved  |
   | %r11 | %r11d | %r11w | %r11b | caller saved  |
   | %r12 | %r12d | %r12w | %r12b | callee saved  |
   | %r13 | %r13d | %r13w | %r13b | callee saved  |
   | %r14 | %r14d | %r14w | %r14b | callee saved  |
   | %r15 | %r15d | %r15w | %r15b | callee saved  |

   
   #+CAPTION: Operand forms
   #+SUMMARY: factor s must be either 1, 2, 4, or 8
   #+SUMMARY: common memory referrence, Imm[r_b, r_i, s)
   | Type      | Form           | Operand value                | Name                |
   |-----------+----------------+------------------------------+---------------------|
   | Immediate | $Imm           | Imm                          | Immediate           |
   | Register  | r_a            | R[r_a]                       | Register            |
   | Memory    | Imm            | M[Imm]                       | Absolute            |
   | Memory    | (r_a)          | M[R[r_a]]                    | Indirect            |
   | Memory    | Imm(r_b)       | M[Imm + R[r_b]]              | Base + displacement |
   | Memory    | (r_b,r_i)      | M[R[r_b] + R[r_i]]           | Indexed             |
   | Memory    | Imm(r_b,r_i)   | M[Imm + R[r_b] + R[r_i]]     | Indexed             |
   | Memory    | (,r_i,s)       | M[R[r_i] * s]                | Scaled indexed      |
   | Memory    | Imm(,r_i,s)    | M[Imm + R[r_i] * s]          | Scaled indexed      |
   | Memory    | (r_b,r_i,s)    | M[R[r_b] + R[r_i] * s]       | Scaled indexed      |
   | Memory    | Imm(r_b,r_i,s) | M[Imm + R[r_b] + R[r_i] * s] | Scaled indexed      |


** MOVE Instruction

*** MOV
   
    #+CAPTION: MOV S, D
    #+SUMMARY: the *MOV* instructions will only update the specific register bytes or memory locations indicated by the destination operand
    #+SUMMARY: exception is *movl* has a register as the destination, it will also set the high order 4 bytes of the register to 0
    | Instruction | Effect | Description             |
    |-------------+--------+-------------------------|
    | movb        | D <- S | move byte               |
    | movw        | D <- S | move word               |
    | movl        | D <- S | move double word        |
    | movq        | D <- S | move quad word          |
    | movabsq     | R <- I | move absolute quad word |


*** MOVZ
   
    #+CAPTION: MOVZ S, R
    #+SUMMARY: the *movz* have a register or memory location as the source and a register as the destination
    | Instruction | Effect             | Description                            |
    |-------------+--------------------+----------------------------------------|
    | movzbw      | R <- ZeroExtend(S) | move zero-extended byte to word        |
    | movzbl      | R <- ZeroExtend(S) | move zero-extended byte to double word |
    | movzwl      | R <- ZeroExtend(S) | move zero-extended word to double word |
    | movzbq      | R <- ZeroExtend(S) | move zero-extended byte to quad word   |
    | movzwq      | R <- ZeroExtend(S) | move zero-extended word to quad word   |


*** MOVS

    #+CAPTION: MOVS S, R
    #+SUMMARY: the *movs* instructions have a register or memory location as the source and a register as the destination
    | Instruction | Effect                   | Description                                 |
    |-------------+--------------------------+---------------------------------------------|
    | movsbw      | R <- SignExtend(S)       | move sign-extended byte to word             |
    | movsbl      | R <- SignExtend(S)       | move sign-extended byte to double word      |
    | movswl      | R <- SignExtend(S)       | move sign-extended word to double word      |
    | movsbq      | R <- SignExtend(S)       | move sign-extended byte to quad word        |
    | movswq      | R <- SignExtend(S)       | move sign-extended word to quad word        |
    | movslq      | R <- SignExtend(S)       | move sign-extended double word to quad word |
    | cltq        | %rax <- SignExtend(%eax) | sign-extend %eax to %rax                    |


*** Stack

    | Instruction | Effect                 | Description    |
    |-------------+------------------------+----------------|
    | pushq S     | R[%rsp] <- R[%rsp] - 8 | push quad word |
    |             | M[R[%rsp]] <- S        |                |
    |-------------+------------------------+----------------|
    | popq D      | D <- M[R[%rsp]]        | pop quad word  |
    |             | R[%rsp] <- R[%rsp] + 8 |                |

    #+BEGIN_SRC as

    . pushq s
    subq $8, %rsp             . Decrement stack pointer
    movq %rbp, (%rsp)         . Store %rbp on stack

    . popq d
    movq (%rsp), %rax         . Read %rax from stack
    addq $8, %rsp             . Increment stack pointer

    #+END_SRC


** Arithmetic and Logical Operations

   | Instruction |      | Effect         | Description              |
   |-------------+------+----------------+--------------------------|
   | leaq        | S, D | D <- &S        | load effective address   |
   | INC         | D    | D <- D + 1     | increment                |
   | DEC         | D    | D <- D - 1     | decrement                |
   | NEG         | D    | D < -D         | negate                   |
   | NOT         | D    | D <- ~D        | complement               |
   | ADD         | S, D | D <- D + S     | add                      |
   | SUB         | S, D | D <- D - S     | substract                |
   | IMUL        | S, D | D <- D * S     | multiply                 |
   | XOR         | S, D | D <- D ^ S     | exclusive-or             |
   | OR          | S, D | D <- D \vbar S | or                       |
   | AND         | S, D | D <- D & S     | and                      |
   | SAL         | k, D | D <- D << k    | left shift               |
   | SHL         | k, D | D <- D << k    | left shift (same as SAL) |
   | SAR         | k, D | D <- D >> k    | arithmetic right shift   |
   | SHR         | k, D | D <- D >>> k   | logical right shift      |


   | Instruction | Effect                                 | Description            |
   |-------------+----------------------------------------+------------------------|
   | imulq S     | R[%rdx]:R[%rax] <- S * R[%rax]         | Signed full multiply   |
   | mulq S      | R[%rdx]:R[%rax] <- S * R[%rax]         | Unsigned full multiply |
   | cqto        | R[%rdx]:R[%rax] <- SignExtend(R[%rax]) | Convert to oct word    |
   | idivq S     | R[%rdx] <- R[%rdx]:R[%rax] mod S       | Signed divide          |
   |             | R[%rax] <- R[%rdx]:R[%rax] / S         |                        |
   | divq S      | R[%rdx] <- R[%rdx]:R[%rax] mod S       | Unsigned divide        |
   |             | R[%rax] <- R[%rdx]:R[%rax] / S         |                        |


** Control
 
*** CMP

    #+SUMMARY: thest instruction set the condition codes without updating any other registers
    | Instruction |          | Based on  | Description         |
    |-------------+----------+-----------+---------------------|
    | cmpb        | S_1, S_2 | S_2 - S_1 | compare byte        |
    | cmpw        | S_1, S_2 | S_2 - S_1 | compare word        |
    | cmpl        | S_1, S_2 | S_2 - S_1 | compare double word |
    | cmpq        | S_1, S_2 | S_2 - S_1 | compare quad word   |



*** TEST

    #+SUMMARY: thest instruction set the condition codes without updating any other registers
    | Instruction |          | Based on  | Description      |
    |-------------+----------+-----------+------------------|
    | testb       | S_1, S_2 | S_1 & S_2 | test byte        |
    | testw       | S_1, S_2 | S_1 & S_2 | test word        |
    | testl       | S_1, S_2 | S_1 & S_2 | test double word |
    | testq       | S_1, S_2 | S_1 & S_2 | test quad word   |



*** SET

    | Instruction | Synonym | Effect                  | Set condition                |
    |-------------+---------+-------------------------+------------------------------|
    | sete D      | setz    | D <- ZF                 | equal / zero                 |
    | setne D     | setnz   | D <- ~ZF                | not equal / not zero         |
    | sets D      |         | D <- SF                 | negative                     |
    | setns D     |         | D <- ~SF                | nonnegative                  |
    | setg D      | setnle  | D <- ~(SF ^ OF) & ~ZF   | greater (signed >)           |
    | setge D     | setnl   | D <- ~(SF ^ OF)         | greater or equal (signed >=) |
    | setl D      | setnge  | D <- SF ^ OF            | less (signed <)              |
    | setle D     | setng   | D <- (SF ^ OF) \vbar ZF | less or equal (signed <=)    |
    | seta D      | setnbe  | D <- ~CF & ~ZF          | above (unsigned >)           |
    | setae D     | setnb   | D <- ~CF                | above or equal (unsigned >=) |
    | setb D      | setnae  | D <- CF                 | below (unsigned <)           |
    | setbe D     | setna   | D <- CF \vbar CF        | below or equal (unsigned <=) |


*** Condition Codes

**** CF

     Carry flag. The most recent operation generated a carry out of the most significant bit.

     _Used to detect overflow for unsigned operations_

**** ZF

     Zero flag. The most recent operation yielded zero.

**** SF

     Sign flag. The most recent operation yielded a negative value.

**** OF

     Overflow flag. The most recent operation caused a two's-complement overflow -- either negative or positive.


*** JUMP

    | Instruction  | Synonym | Jump Condition     | Description                  |
    |--------------+---------+--------------------+------------------------------|
    | jmp Label    |         | 1                  | direct jump                  |
    | jmp *Operand |         | 1                  | indirect jump                |
    | je  Label    | jz      | ZF                 | equal / zero                 |
    | jne Label    | jnz     | ~ZF                | not equal / not zero         |
    | js  Label    |         | SF                 | negative                     |
    | jns Label    |         | ~SF                | nonnegative                  |
    | jg  Label    | jnle    | ~(SF ^ OF) & ~ZF   | greater (signed >)           |
    | jge Label    | jnl     | ~(SF ^ OF)         | greater or equal (signed >=) |
    | jl  Label    | jnge    | SF ^ OF            | less (signed <)              |
    | jle Label    | jng     | (SF ^ OF) \vbar ZF | less or equal (signed <=)    |
    | ja  Label    | jnbe    | ~CF & ~ZF          | above (unsigned >)           |
    | jae Label    | jnb     | ~CF                | above or equal (unsigned >=) |
    | jb  Label    | jnae    | CF                 | below (unsigned <)           |
    | jbe Label    | jna     | CF \vbar ZF        | below or equal (unsigned <=) |

*** CMOV

    | Instruction  | Synonym | Move condition     | Description                  |
    |--------------+---------+--------------------+------------------------------|
    | cmove   S, R | cmovz   | ZF                 | equal / zero                 |
    | cmovene S, R | cmovnz  | ~ZF                | not equal / not zero         |
    | cmovs   S, R |         | SF                 | negative                     |
    | cmovns  S, R |         | ~SF                | nonnegative                  |
    | cmovg   S, R | comvnle | ~(SF ^ OF) & ~ZF   | greater (signed >)           |
    | cmovge  S, R | comvnl  | ~(SF ^ OF)         | greater or equal (signed >=) |
    | cmovl   S, R | cmovnge | SF ^ OF            | less (signed <)              |
    | cmovle  S, R | cmovng  | (SF ^ OF) \vbar ZF | less or equal (signed <=)    |
    | cmova   S, R | cmovnbe | ~CF & ~ZF          | above (unsigned >)           |
    | cmovae  S, R | cmovnb  | ~CF                | above or equal (unsigned <=) |
    | cmovb   S, R | cmovnae | CF                 | below (unsigned <)           |
    | cmovbe  S, R | cmovna  | CF \vbar ZF        | below (unsigned <=)          |


    #+BEGIN_EXAMPLE

    v = test-expr? then-expr : else-expr;

    if (!test-expr) {
        goto false;
    }
    v = then-expr;
    goto done;

false:
    v = else-expr;
done: 
    

    v = then-expr;
    ve = else-expr;
    t = test-expr;
    if (!t) v = ve;

    
    #+END_EXAMPLE


    #+BEGIN_EXAMPLE do-while

    do {
        body-statement
    } while (test-expr);

    
    loop:
        body-statement
        t = test-expr
        if (t) {
            goto loop;
        }
    
    #+END_EXAMPLE


    #+BEGIN_EXAMPLE while

    while (test-expr) {
        body-statement
    }

    
    goto test;
    loop: 
        body-statement
    test:
        t = test-expr;
        if (t) {
            goto loop;
        }


    t = test-expr;
    if (!t) {
        goto done;
    }
    do {
        body-statement
    } while (test-expr);
    done:

    t = test-expr;
    if (!t) {
        goto done;
    }
    loop:
        body-statement
        t = test-expr;
        if (t)
            goto loop;
    done:
    
    #+END_EXAMPLE


    #+BEGIN_EXAMPLE for

    for (init-expr; test-expr; update-expr) {
        body-statement
    }

    init-expr;
    while (test-expr) {
        body-statement
        update-expr;
    }
    
    #+END_EXAMPLE
